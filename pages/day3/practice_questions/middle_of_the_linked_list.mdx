import { Tab, Tabs, Steps } from "nextra-theme-docs";

### Middle of the Linked List

#### Description

-   Given the `head` of a singly linked list, return the **middle node** of the linked list. If there are two middle nodes, return the **_second middle node_**.

#### Constraints

-   The number of nodes in the list is in the range `[1, 100]`.
-   `1 <= Node.val <= 100`

#### Test Cases

-   Input: `head = [1,2,3,4,5,6]` <br />
    Output: `[4,5,6]`

-   Input: `head = [1,2,3,4,5]` <br />
    Output: `[3,4,5]`

#### Code

<Steps>

    ##### Approach 1: `Using length of the list`

    <Tabs items={['C++', 'Python']} defaultIndex="0">
        <Tab>
        ```cpp copy
        ListNode *middleNode(ListNode *head)
        {
            ListNode *temp = head;
            int length = 0;
            while (temp != nullptr)
            {
                temp = temp->next;
                length++;
            }

            temp = head;
            int i = 0;
            while (i < length / 2)
            {
                temp = temp->next;
                i++;
            }
            return temp;
        }
        ```
        </Tab>

        <Tab>
        ```python copy
        def middleNode(self, head):
            length = 0
            temp = head
            while temp:
                length += 1
                temp = temp.next

            temp = head
            for i in range(length//2):
                temp = temp.next
            return temp
        ```

        </Tab>

        #### Explanation

        1. Find the `length` of the list.
        2. Traverse the list till the middle of the list. (length/2)
        3. Return the node at the `middle` of the list.

        #### Analysis

        - Time Complexity: `O(n)`
        - Space Complexity: `O(1)`

    </Tabs>

    ---

    ##### Approach 2: `Using slow and fast pointer`

    <Tabs items={['C++', 'Python']} defaultIndex="0">
        <Tab>
        ```cpp copy
        ListNode *middleNode(ListNode *head)
        {
            ListNode *slow = head;
            ListNode *fast = head;

            while (fast != nullptr && fast->next != nullptr)
            {
                fast = fast->next->next;
                slow = slow->next;
            }
            return slow;
        }
        ```
        </Tab>

        <Tab>
        ```python copy
        def middleNode(self, head):
            slow = fast = head
            while fast and fast.next:
                slow = slow.next
                fast = fast.next.next
            return slow
        ```
        </Tab>

        #### Explanation

        1. Initialize two pointers `slow` and `fast` to the head of the list.
        2. Traverse the list with `fast` pointer moving two nodes at a time and `slow` pointer moving one node at a time.
        3. When `fast` pointer reaches the end of the list, `slow` pointer will be at the middle of the list.
        4. Return the node at the middle of the list.

        #### Analysis

        - Time Complexity: `O(n)`
        - Space Complexity: `O(1)`

    </Tabs>

</Steps>
