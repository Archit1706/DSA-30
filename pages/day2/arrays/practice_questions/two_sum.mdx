import { Tabs, Callout } from "nextra/components";
import { DifficultyBadge } from "../../../../components/DifficultyBadge";
import { AlgorithmStepper } from "../../../../components/AlgorithmStepper";
export const Tab = Tabs.Tab

### Two Sum <DifficultyBadge level="easy" />

#### Description

Given an array of integers `nums` and an integer `target`, return the **indices** of the two numbers such that they add up to `target`.

You may assume that each input would have **exactly one solution**, and you may not use the same element twice.

#### Examples

```py
> Case 1:
    Input: nums = [2, 7, 11, 15], target = 9
    Output: [0, 1]
    Explanation: nums[0] + nums[1] = 2 + 7 = 9

> Case 2:
    Input: nums = [3, 2, 4], target = 6
    Output: [1, 2]

> Case 3:
    Input: nums = [3, 3], target = 6
    Output: [0, 1]
```

#### Constraints

-   `2 <= nums.length <= 10^4`
-   `-10^9 <= nums[i] <= 10^9`
-   `-10^9 <= target <= 10^9`
-   Only one valid answer exists.

#### Approach 1: Brute Force

Check every pair of elements. Simple but slow.

<Tabs items={['C++', 'Python']} defaultIndex="0">
    <Tab>
    ```cpp copy
    #include <vector>
    using namespace std;

    vector<int> twoSum(vector<int>& nums, int target) {
        int n = nums.size();
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (nums[i] + nums[j] == target) {
                    return {i, j};
                }
            }
        }
        return {};  // No solution found
    }
    ```

    - Time Complexity: `O(n^2)` -- nested loops checking every pair
    - Space Complexity: `O(1)`

    </Tab>
    <Tab>
    ```python copy
    def two_sum_brute(nums, target):
        n = len(nums)
        for i in range(n):
            for j in range(i + 1, n):
                if nums[i] + nums[j] == target:
                    return [i, j]
        return []
    ```

    - Time Complexity: `O(n^2)`
    - Space Complexity: `O(1)`

    </Tab>
</Tabs>

#### Approach 2: Hash Map (Optimal)

The key insight: for each number `x`, we need to find if `target - x` already exists. A hash map gives us O(1) lookups.

<AlgorithmStepper
    title="Hash Map approach: nums=[2, 7, 11, 15], target=9"
    steps={[
        { array: [2, 7, 11, 15], activeIndices: [0], description: "i=0, num=2. Need 9-2=7. Map is empty, so 7 not found. Store {2: 0}." },
        { array: [2, 7, 11, 15], activeIndices: [1], description: "i=1, num=7. Need 9-7=2. Found 2 in map at index 0! Return [0, 1]." },
    ]}
/>

<Tabs items={['C++', 'Python']} defaultIndex="0">
    <Tab>
    ```cpp copy
    #include <vector>
    #include <unordered_map>
    using namespace std;

    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> seen;  // value -> index

        for (int i = 0; i < nums.size(); i++) {
            int complement = target - nums[i];

            if (seen.count(complement)) {
                return {seen[complement], i};
            }

            seen[nums[i]] = i;
        }

        return {};
    }
    ```
    </Tab>
    <Tab>
    ```python copy
    def two_sum(nums, target):
        seen = {}  # value -> index

        for i, num in enumerate(nums):
            complement = target - num

            if complement in seen:
                return [seen[complement], i]

            seen[num] = i

        return []

    # Example
    print(two_sum([2, 7, 11, 15], 9))  # [0, 1]
    print(two_sum([3, 2, 4], 6))        # [1, 2]
    ```
    </Tab>
</Tabs>

#### Explanation

- We iterate through the array once
- For each element, we calculate what its "complement" would be: `target - nums[i]`
- We check if we've already seen this complement in our hash map
- If yes, we found our pair and return both indices
- If no, we store the current element and its index in the map for future lookups
- The hash map trades O(n) space for O(1) lookups, turning an O(n^2) problem into O(n)

<Callout type="info">
    **Why this is problem #1 on LeetCode:** Two Sum teaches the fundamental
    pattern of using a hash map to convert "find a pair" problems from O(n^2)
    to O(n). This same pattern appears in dozens of other problems.
</Callout>

#### Analysis

- Time Complexity: `O(n)` -- single pass through the array
- Space Complexity: `O(n)` -- hash map stores at most n elements
