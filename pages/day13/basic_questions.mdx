import { Tabs,Steps } from "nextra/components";
export const Tab = Tabs.Tab
import { ShowHideSolution } from "../../components/ShowHideSolution";
import { ShowHideGif } from "../../components/ShowHideGif";
import React from "react";

## Basic Questions

<Steps>

### Find the Index of an Element in an Array

#### Code

<Tabs items={['C++', 'Python']} defaultIndex="0">
    <Tab>
    ```cpp copy
    int linearSearch(int arr[], int n, int x) {
        for (int i = 0; i < n; i++) {
            if (arr[i] == x) {
                return i;
            }
        }
        return -1;
    }
    ```

    </Tab>

    <Tab>
    ```python copy
    def linear_search(arr, n, x):
        for i in range(n):
            if arr[i] == x:
                return i
        return -1
    ```
    </Tab>

</Tabs>

#### Explanation

1. The function `linearSearch` (or `linear_search` in Python) iterates through the array `arr` to find the element `x`.
2. If the element is found, the function returns its index; otherwise, it returns `-1`.

#### Analysis

-   Time Complexity: `O(n)`
-   Space Complexity: `O(1)`

### Find an Element in a Sorted Array Using Binary Search

#### Code

<Tabs items={['C++', 'Python']} defaultIndex="0">
    <Tab>
    ```cpp copy
    int binarySearch(int arr[], int n, int x) {
        int left = 0, right = n - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (arr[mid] == x) {
                return mid;
            }
            if (arr[mid] < x) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return -1;
    }
    ```

    </Tab>

    <Tab>
    ```python copy
    def binary_search(arr, n, x):
        left, right = 0, n - 1
        while left <= right:
            mid = left + (right - left) // 2
            if arr[mid] == x:
                return mid
            if arr[mid] < x:
                left = mid + 1
            else:
                right = mid - 1
        return -1
    ```
    </Tab>

</Tabs>

#### Explanation

1. The function `binarySearch` (or `binary_search` in Python) divides the array into halves and checks if the middle element is the target `x`.
2. If `x` is less than the middle element, it searches the left half; if greater, it searches the right half.
3. The process continues until the element is found or the search space is exhausted.

#### Analysis

-   Time Complexity: `O(log n)`
-   Space Complexity: `O(1)`

</Steps>

{/* home work problems */}

> **Note**: Once you have understood the above examples, try to solve the following problems on your own.

### Extra Problems

1.  **Find the First and Last Position of an Element in a Sorted Array**

<ShowHideSolution>

    <Tabs items={['C++', 'Python']} defaultIndex="0">
        <Tab>
        ```cpp copy
        int firstOccurrence(int arr[], int n, int x) {
            int left = 0, right = n - 1, result = -1;
            while (left <= right) {
                int mid = left + (right - left) / 2;
                if (arr[mid] == x) {
                    result = mid;
                    right = mid - 1; // continue searching in the left half
                } else if (arr[mid] < x) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
            return result;
        }

        int lastOccurrence(int arr[], int n, int x) {
            int left = 0, right = n - 1, result = -1;
            while (left <= right) {
                int mid = left + (right - left) / 2;
                if (arr[mid] == x) {
                    result = mid;
                    left = mid + 1; // continue searching in the right half
                } else if (arr[mid] < x) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
            return result;
        }
        ```

        </Tab>

        <Tab>
        ```python copy
        def first_occurrence(arr, n, x):
            left, right, result = 0, n - 1, -1
            while left <= right:
                mid = left + (right - left) // 2
                if arr[mid] == x:
                    result = mid
                    right = mid - 1 # continue searching in the left half
                elif arr[mid] < x:
                    left = mid + 1
                else:
                    right = mid - 1
            return result

        def last_occurrence(arr, n, x):
            left, right, result = 0, n - 1, -1
            while left <= right:
                mid = left + (right - left) // 2
                if arr[mid] == x:
                    result = mid
                    left = mid + 1 # continue searching in the right half
                elif arr[mid] < x:
                    left = mid + 1
                else:
                    right = mid - 1
            return result
        ```
        </Tab>
    </Tabs>

</ShowHideSolution>

2. **Find the Square Root of a Number Using Binary Search**

<ShowHideSolution>

    <Tabs items={['C++', 'Python']} defaultIndex="0">
        <Tab>
        ```cpp copy
        int sqrtBinarySearch(int x) {
            if (x == 0 || x == 1) return x;
            int left = 1, right = x / 2, result = 1;
            while (left <= right) {
                int mid = left + (right - left) / 2;
                if (mid == x / mid) return mid;
                if (mid < x / mid) {
                    left = mid + 1;
                    result = mid;
                } else {
                    right = mid - 1;
                }
            }
            return result;
        }
        ```

        </Tab>

        <Tab>
        ```python copy
        def sqrt_binary_search(x):
            if x == 0 or x == 1:
                return x
            left, right, result = 1, x // 2, 1
            while left <= right:
                mid = left + (right - left) // 2
                if mid == x // mid:
                    return mid
                elif mid < x // mid:
                    left = mid + 1
                    result = mid
                else:
                    right = mid - 1
            return result
        ```
        </Tab>
    </Tabs>

</ShowHideSolution>
